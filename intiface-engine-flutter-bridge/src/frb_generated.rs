// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.30.

#![allow(
  non_camel_case_types,
  unused,
  non_snake_case,
  clippy::needless_return,
  clippy::redundant_closure_call,
  clippy::redundant_closure,
  clippy::useless_conversion,
  clippy::unit_arg,
  clippy::unused_unit,
  clippy::double_parens,
  clippy::let_and_return,
  clippy::too_many_arguments,
  clippy::match_single_binding
)]

// Section: imports

use crate::api::simple::*;
use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::transform_result_dco;
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
  default_stream_sink_codec = SseCodec,
  default_rust_opaque = RustOpaqueMoi,
  default_rust_auto_opaque = RustAutoOpaqueMoi,
);
const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.0.0-dev.30";

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire_crash_reporting_impl(
  port_: flutter_rust_bridge::for_generated::MessagePort,
  ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
  rust_vec_len_: i32,
  data_len_: i32,
) {
  FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
    flutter_rust_bridge::for_generated::TaskInfo {
      debug_name: "crash_reporting",
      port: Some(port_),
      mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
    },
    move || {
      let message = unsafe {
        flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
          ptr_,
          rust_vec_len_,
          data_len_,
        )
      };
      let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
      let api_sentry_api_key = <String>::sse_decode(&mut deserializer);
      deserializer.end();
      move |context| {
        transform_result_sse((move || {
          Result::<_, ()>::Ok(crate::api::simple::crash_reporting(api_sentry_api_key))
        })())
      }
    },
  )
}
fn wire_generate_user_device_config_file_impl(
  port_: flutter_rust_bridge::for_generated::MessagePort,
  ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
  rust_vec_len_: i32,
  data_len_: i32,
) {
  FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
    flutter_rust_bridge::for_generated::TaskInfo {
      debug_name: "generate_user_device_config_file",
      port: Some(port_),
      mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
    },
    move || {
      let message = unsafe {
        flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
          ptr_,
          rust_vec_len_,
          data_len_,
        )
      };
      let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
      let api_user_config = <crate::api::simple::ExposedUserConfig>::sse_decode(&mut deserializer);
      deserializer.end();
      move |context| {
        transform_result_sse((move || {
          Result::<_, ()>::Ok(crate::api::simple::generate_user_device_config_file(
            api_user_config,
          ))
        })())
      }
    },
  )
}
fn wire_get_protocol_names_impl(
  port_: flutter_rust_bridge::for_generated::MessagePort,
  ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
  rust_vec_len_: i32,
  data_len_: i32,
) {
  FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
    flutter_rust_bridge::for_generated::TaskInfo {
      debug_name: "get_protocol_names",
      port: Some(port_),
      mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
    },
    move || {
      let message = unsafe {
        flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
          ptr_,
          rust_vec_len_,
          data_len_,
        )
      };
      let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
      deserializer.end();
      move |context| {
        transform_result_sse((move || {
          Result::<_, ()>::Ok(crate::api::simple::get_protocol_names())
        })())
      }
    },
  )
}
fn wire_get_user_configs_impl(
  port_: flutter_rust_bridge::for_generated::MessagePort,
  ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
  rust_vec_len_: i32,
  data_len_: i32,
) {
  FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
    flutter_rust_bridge::for_generated::TaskInfo {
      debug_name: "get_user_configs",
      port: Some(port_),
      mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
    },
    move || {
      let message = unsafe {
        flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
          ptr_,
          rust_vec_len_,
          data_len_,
        )
      };
      let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
      deserializer.end();
      move |context| {
        transform_result_sse((move || {
          Result::<_, ()>::Ok(crate::api::simple::get_user_configs())
        })())
      }
    },
  )
}
fn wire_get_user_device_configs_impl(
  port_: flutter_rust_bridge::for_generated::MessagePort,
  ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
  rust_vec_len_: i32,
  data_len_: i32,
) {
  FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
    flutter_rust_bridge::for_generated::TaskInfo {
      debug_name: "get_user_device_configs",
      port: Some(port_),
      mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
    },
    move || {
      let message = unsafe {
        flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
          ptr_,
          rust_vec_len_,
          data_len_,
        )
      };
      let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
      let api_device_config_json = <String>::sse_decode(&mut deserializer);
      let api_user_config_json = <String>::sse_decode(&mut deserializer);
      deserializer.end();
      move |context| {
        transform_result_sse((move || {
          Result::<_, ()>::Ok(crate::api::simple::get_user_device_configs(
            api_device_config_json,
            api_user_config_json,
          ))
        })())
      }
    },
  )
}
fn wire_run_engine_impl(
  port_: flutter_rust_bridge::for_generated::MessagePort,
  ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
  rust_vec_len_: i32,
  data_len_: i32,
) {
  FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
    flutter_rust_bridge::for_generated::TaskInfo {
      debug_name: "run_engine",
      port: Some(port_),
      mode: flutter_rust_bridge::for_generated::FfiCallMode::Stream,
    },
    move || {
      let message = unsafe {
        flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
          ptr_,
          rust_vec_len_,
          data_len_,
        )
      };
      let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
      let api_args = <crate::api::simple::EngineOptionsExternal>::sse_decode(&mut deserializer);
      deserializer.end();
      move |context| {
        transform_result_sse((move || {
          crate::api::simple::run_engine(
            StreamSink::new(context.rust2dart_context().stream_sink::<_, String>()),
            api_args,
          )
        })())
      }
    },
  )
}
fn wire_runtime_started_impl(
  port_: flutter_rust_bridge::for_generated::MessagePort,
  ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
  rust_vec_len_: i32,
  data_len_: i32,
) {
  FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
    flutter_rust_bridge::for_generated::TaskInfo {
      debug_name: "runtime_started",
      port: Some(port_),
      mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
    },
    move || {
      let message = unsafe {
        flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
          ptr_,
          rust_vec_len_,
          data_len_,
        )
      };
      let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
      deserializer.end();
      move |context| {
        transform_result_sse((move || {
          Result::<_, ()>::Ok(crate::api::simple::runtime_started())
        })())
      }
    },
  )
}
fn wire_send_impl(
  port_: flutter_rust_bridge::for_generated::MessagePort,
  ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
  rust_vec_len_: i32,
  data_len_: i32,
) {
  FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
    flutter_rust_bridge::for_generated::TaskInfo {
      debug_name: "send",
      port: Some(port_),
      mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
    },
    move || {
      let message = unsafe {
        flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
          ptr_,
          rust_vec_len_,
          data_len_,
        )
      };
      let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
      let api_msg_json = <String>::sse_decode(&mut deserializer);
      deserializer.end();
      move |context| {
        transform_result_sse((move || {
          Result::<_, ()>::Ok(crate::api::simple::send(api_msg_json))
        })())
      }
    },
  )
}
fn wire_send_backend_server_message_impl(
  port_: flutter_rust_bridge::for_generated::MessagePort,
  ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
  rust_vec_len_: i32,
  data_len_: i32,
) {
  FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
    flutter_rust_bridge::for_generated::TaskInfo {
      debug_name: "send_backend_server_message",
      port: Some(port_),
      mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
    },
    move || {
      let message = unsafe {
        flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
          ptr_,
          rust_vec_len_,
          data_len_,
        )
      };
      let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
      let api_msg = <String>::sse_decode(&mut deserializer);
      deserializer.end();
      move |context| {
        transform_result_sse((move || {
          Result::<_, ()>::Ok(crate::api::simple::send_backend_server_message(api_msg))
        })())
      }
    },
  )
}
fn wire_setup_logging_impl(
  port_: flutter_rust_bridge::for_generated::MessagePort,
  ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
  rust_vec_len_: i32,
  data_len_: i32,
) {
  FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
    flutter_rust_bridge::for_generated::TaskInfo {
      debug_name: "setup_logging",
      port: Some(port_),
      mode: flutter_rust_bridge::for_generated::FfiCallMode::Stream,
    },
    move || {
      let message = unsafe {
        flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
          ptr_,
          rust_vec_len_,
          data_len_,
        )
      };
      let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
      deserializer.end();
      move |context| {
        transform_result_sse((move || {
          Result::<_, ()>::Ok(crate::api::simple::setup_logging(StreamSink::new(
            context.rust2dart_context().stream_sink::<_, String>(),
          )))
        })())
      }
    },
  )
}
fn wire_shutdown_logging_impl(
  port_: flutter_rust_bridge::for_generated::MessagePort,
  ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
  rust_vec_len_: i32,
  data_len_: i32,
) {
  FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
    flutter_rust_bridge::for_generated::TaskInfo {
      debug_name: "shutdown_logging",
      port: Some(port_),
      mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
    },
    move || {
      let message = unsafe {
        flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
          ptr_,
          rust_vec_len_,
          data_len_,
        )
      };
      let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
      deserializer.end();
      move |context| {
        transform_result_sse((move || {
          Result::<_, ()>::Ok(crate::api::simple::shutdown_logging())
        })())
      }
    },
  )
}
fn wire_stop_engine_impl(
  port_: flutter_rust_bridge::for_generated::MessagePort,
  ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
  rust_vec_len_: i32,
  data_len_: i32,
) {
  FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
    flutter_rust_bridge::for_generated::TaskInfo {
      debug_name: "stop_engine",
      port: Some(port_),
      mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
    },
    move || {
      let message = unsafe {
        flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
          ptr_,
          rust_vec_len_,
          data_len_,
        )
      };
      let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
      deserializer.end();
      move |context| {
        transform_result_sse((move || {
          Result::<_, ()>::Ok(crate::api::simple::stop_engine())
        })())
      }
    },
  )
}

// Section: static_checks

#[allow(clippy::unnecessary_literal_unwrap)]
const _: fn() = || {
  {
    let EngineOptionsExternal = None::<crate::api::simple::EngineOptionsExternal>.unwrap();
    let _: Option<String> = EngineOptionsExternal.device_config_json;
    let _: Option<String> = EngineOptionsExternal.user_device_config_json;
    let _: String = EngineOptionsExternal.server_name;
    let _: bool = EngineOptionsExternal.websocket_use_all_interfaces;
    let _: Option<u16> = EngineOptionsExternal.websocket_port;
    let _: Option<u16> = EngineOptionsExternal.frontend_websocket_port;
    let _: bool = EngineOptionsExternal.frontend_in_process_channel;
    let _: u32 = EngineOptionsExternal.max_ping_time;
    let _: bool = EngineOptionsExternal.allow_raw_messages;
    let _: bool = EngineOptionsExternal.use_bluetooth_le;
    let _: bool = EngineOptionsExternal.use_serial_port;
    let _: bool = EngineOptionsExternal.use_hid;
    let _: bool = EngineOptionsExternal.use_lovense_dongle_serial;
    let _: bool = EngineOptionsExternal.use_lovense_dongle_hid;
    let _: bool = EngineOptionsExternal.use_xinput;
    let _: bool = EngineOptionsExternal.use_lovense_connect;
    let _: bool = EngineOptionsExternal.use_device_websocket_server;
    let _: Option<u16> = EngineOptionsExternal.device_websocket_server_port;
    let _: bool = EngineOptionsExternal.crash_main_thread;
    let _: bool = EngineOptionsExternal.crash_task_thread;
    let _: Option<String> = EngineOptionsExternal.websocket_client_address;
    let _: bool = EngineOptionsExternal.broadcast_server_mdns;
    let _: Option<String> = EngineOptionsExternal.mdns_suffix;
    let _: bool = EngineOptionsExternal.repeater_mode;
    let _: Option<u16> = EngineOptionsExternal.repeater_local_port;
    let _: Option<String> = EngineOptionsExternal.repeater_remote_address;
  }
  {
    let UserConfigDeviceIdentifier =
      None::<crate::api::simple::UserConfigDeviceIdentifier>.unwrap();
    let _: String = UserConfigDeviceIdentifier.address;
    let _: String = UserConfigDeviceIdentifier.protocol;
    let _: Option<String> = UserConfigDeviceIdentifier.identifier;
  }
};

// Section: related_funcs

flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
  flutter_rust_bridge::for_generated::rust_async::RwLock<ProtocolAttributesIdentifier>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
  flutter_rust_bridge::for_generated::rust_async::RwLock<ProtocolDeviceFeatures>
);

// Section: dart2rust

impl SseDecode for flutter_rust_bridge::for_generated::anyhow::Error {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
    unreachable!("");
  }
}

impl SseDecode for ProtocolAttributesIdentifier {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
    let mut inner = <RustOpaqueMoi<
      flutter_rust_bridge::for_generated::rust_async::RwLock<ProtocolAttributesIdentifier>,
    >>::sse_decode(deserializer);
    return inner.rust_auto_opaque_decode_owned();
  }
}

impl SseDecode for ProtocolDeviceFeatures {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
    let mut inner = <RustOpaqueMoi<
      flutter_rust_bridge::for_generated::rust_async::RwLock<ProtocolDeviceFeatures>,
    >>::sse_decode(deserializer);
    return inner.rust_auto_opaque_decode_owned();
  }
}

impl SseDecode for std::collections::HashMap<ProtocolAttributesIdentifier, ProtocolDeviceFeatures> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
    let mut inner =
      <Vec<(ProtocolAttributesIdentifier, ProtocolDeviceFeatures)>>::sse_decode(deserializer);
    return inner.into_iter().collect();
  }
}

impl SseDecode
  for RustOpaqueMoi<
    flutter_rust_bridge::for_generated::rust_async::RwLock<ProtocolAttributesIdentifier>,
  >
{
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
    let mut inner = <usize>::sse_decode(deserializer);
    return decode_rust_opaque_moi(inner);
  }
}

impl SseDecode
  for RustOpaqueMoi<flutter_rust_bridge::for_generated::rust_async::RwLock<ProtocolDeviceFeatures>>
{
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
    let mut inner = <usize>::sse_decode(deserializer);
    return decode_rust_opaque_moi(inner);
  }
}

impl SseDecode for String {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
    let mut inner = <Vec<u8>>::sse_decode(deserializer);
    return String::from_utf8(inner).unwrap();
  }
}

impl SseDecode for bool {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
    deserializer.cursor.read_u8().unwrap() != 0
  }
}

impl SseDecode for crate::api::simple::EngineOptionsExternal {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
    let mut var_deviceConfigJson = <Option<String>>::sse_decode(deserializer);
    let mut var_userDeviceConfigJson = <Option<String>>::sse_decode(deserializer);
    let mut var_serverName = <String>::sse_decode(deserializer);
    let mut var_websocketUseAllInterfaces = <bool>::sse_decode(deserializer);
    let mut var_websocketPort = <Option<u16>>::sse_decode(deserializer);
    let mut var_frontendWebsocketPort = <Option<u16>>::sse_decode(deserializer);
    let mut var_frontendInProcessChannel = <bool>::sse_decode(deserializer);
    let mut var_maxPingTime = <u32>::sse_decode(deserializer);
    let mut var_allowRawMessages = <bool>::sse_decode(deserializer);
    let mut var_useBluetoothLe = <bool>::sse_decode(deserializer);
    let mut var_useSerialPort = <bool>::sse_decode(deserializer);
    let mut var_useHid = <bool>::sse_decode(deserializer);
    let mut var_useLovenseDongleSerial = <bool>::sse_decode(deserializer);
    let mut var_useLovenseDongleHid = <bool>::sse_decode(deserializer);
    let mut var_useXinput = <bool>::sse_decode(deserializer);
    let mut var_useLovenseConnect = <bool>::sse_decode(deserializer);
    let mut var_useDeviceWebsocketServer = <bool>::sse_decode(deserializer);
    let mut var_deviceWebsocketServerPort = <Option<u16>>::sse_decode(deserializer);
    let mut var_crashMainThread = <bool>::sse_decode(deserializer);
    let mut var_crashTaskThread = <bool>::sse_decode(deserializer);
    let mut var_websocketClientAddress = <Option<String>>::sse_decode(deserializer);
    let mut var_broadcastServerMdns = <bool>::sse_decode(deserializer);
    let mut var_mdnsSuffix = <Option<String>>::sse_decode(deserializer);
    let mut var_repeaterMode = <bool>::sse_decode(deserializer);
    let mut var_repeaterLocalPort = <Option<u16>>::sse_decode(deserializer);
    let mut var_repeaterRemoteAddress = <Option<String>>::sse_decode(deserializer);
    return crate::api::simple::EngineOptionsExternal {
      device_config_json: var_deviceConfigJson,
      user_device_config_json: var_userDeviceConfigJson,
      server_name: var_serverName,
      websocket_use_all_interfaces: var_websocketUseAllInterfaces,
      websocket_port: var_websocketPort,
      frontend_websocket_port: var_frontendWebsocketPort,
      frontend_in_process_channel: var_frontendInProcessChannel,
      max_ping_time: var_maxPingTime,
      allow_raw_messages: var_allowRawMessages,
      use_bluetooth_le: var_useBluetoothLe,
      use_serial_port: var_useSerialPort,
      use_hid: var_useHid,
      use_lovense_dongle_serial: var_useLovenseDongleSerial,
      use_lovense_dongle_hid: var_useLovenseDongleHid,
      use_xinput: var_useXinput,
      use_lovense_connect: var_useLovenseConnect,
      use_device_websocket_server: var_useDeviceWebsocketServer,
      device_websocket_server_port: var_deviceWebsocketServerPort,
      crash_main_thread: var_crashMainThread,
      crash_task_thread: var_crashTaskThread,
      websocket_client_address: var_websocketClientAddress,
      broadcast_server_mdns: var_broadcastServerMdns,
      mdns_suffix: var_mdnsSuffix,
      repeater_mode: var_repeaterMode,
      repeater_local_port: var_repeaterLocalPort,
      repeater_remote_address: var_repeaterRemoteAddress,
    };
  }
}

impl SseDecode for crate::api::simple::ExposedUserConfig {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
    let mut var_specifiers =
      <Vec<(String, crate::api::simple::ExposedUserDeviceSpecifiers)>>::sse_decode(deserializer);
    let mut var_configurations =
      <Vec<crate::api::simple::ExposedUserDeviceConfig>>::sse_decode(deserializer);
    return crate::api::simple::ExposedUserConfig {
      specifiers: var_specifiers,
      configurations: var_configurations,
    };
  }
}

impl SseDecode for crate::api::simple::ExposedUserDeviceConfig {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
    let mut var_identifier =
      <crate::api::simple::UserConfigDeviceIdentifier>::sse_decode(deserializer);
    let mut var_name = <String>::sse_decode(deserializer);
    let mut var_displayName = <Option<String>>::sse_decode(deserializer);
    let mut var_allow = <Option<bool>>::sse_decode(deserializer);
    let mut var_deny = <Option<bool>>::sse_decode(deserializer);
    let mut var_reservedIndex = <Option<u32>>::sse_decode(deserializer);
    return crate::api::simple::ExposedUserDeviceConfig {
      identifier: var_identifier,
      name: var_name,
      display_name: var_displayName,
      allow: var_allow,
      deny: var_deny,
      reserved_index: var_reservedIndex,
    };
  }
}

impl SseDecode for crate::api::simple::ExposedUserDeviceSpecifiers {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
    let mut var_websocket =
      <Option<crate::api::simple::ExposedWebsocketSpecifier>>::sse_decode(deserializer);
    return crate::api::simple::ExposedUserDeviceSpecifiers {
      websocket: var_websocket,
    };
  }
}

impl SseDecode for crate::api::simple::ExposedWebsocketSpecifier {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
    let mut var_names = <Vec<String>>::sse_decode(deserializer);
    return crate::api::simple::ExposedWebsocketSpecifier { names: var_names };
  }
}

impl SseDecode for Vec<String> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
    let mut len_ = <i32>::sse_decode(deserializer);
    let mut ans_ = vec![];
    for idx_ in 0..len_ {
      ans_.push(<String>::sse_decode(deserializer));
    }
    return ans_;
  }
}

impl SseDecode for Vec<crate::api::simple::ExposedUserDeviceConfig> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
    let mut len_ = <i32>::sse_decode(deserializer);
    let mut ans_ = vec![];
    for idx_ in 0..len_ {
      ans_.push(<crate::api::simple::ExposedUserDeviceConfig>::sse_decode(
        deserializer,
      ));
    }
    return ans_;
  }
}

impl SseDecode for Vec<u8> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
    let mut len_ = <i32>::sse_decode(deserializer);
    let mut ans_ = vec![];
    for idx_ in 0..len_ {
      ans_.push(<u8>::sse_decode(deserializer));
    }
    return ans_;
  }
}

impl SseDecode for Vec<(ProtocolAttributesIdentifier, ProtocolDeviceFeatures)> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
    let mut len_ = <i32>::sse_decode(deserializer);
    let mut ans_ = vec![];
    for idx_ in 0..len_ {
      ans_.push(<(ProtocolAttributesIdentifier, ProtocolDeviceFeatures)>::sse_decode(deserializer));
    }
    return ans_;
  }
}

impl SseDecode for Vec<(String, crate::api::simple::ExposedUserDeviceSpecifiers)> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
    let mut len_ = <i32>::sse_decode(deserializer);
    let mut ans_ = vec![];
    for idx_ in 0..len_ {
      ans_.push(
        <(String, crate::api::simple::ExposedUserDeviceSpecifiers)>::sse_decode(deserializer),
      );
    }
    return ans_;
  }
}

impl SseDecode for Option<String> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
    if (<bool>::sse_decode(deserializer)) {
      return Some(<String>::sse_decode(deserializer));
    } else {
      return None;
    }
  }
}

impl SseDecode for Option<bool> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
    if (<bool>::sse_decode(deserializer)) {
      return Some(<bool>::sse_decode(deserializer));
    } else {
      return None;
    }
  }
}

impl SseDecode for Option<crate::api::simple::ExposedWebsocketSpecifier> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
    if (<bool>::sse_decode(deserializer)) {
      return Some(<crate::api::simple::ExposedWebsocketSpecifier>::sse_decode(
        deserializer,
      ));
    } else {
      return None;
    }
  }
}

impl SseDecode for Option<u16> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
    if (<bool>::sse_decode(deserializer)) {
      return Some(<u16>::sse_decode(deserializer));
    } else {
      return None;
    }
  }
}

impl SseDecode for Option<u32> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
    if (<bool>::sse_decode(deserializer)) {
      return Some(<u32>::sse_decode(deserializer));
    } else {
      return None;
    }
  }
}

impl SseDecode for (ProtocolAttributesIdentifier, ProtocolDeviceFeatures) {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
    let mut var_field0 = <ProtocolAttributesIdentifier>::sse_decode(deserializer);
    let mut var_field1 = <ProtocolDeviceFeatures>::sse_decode(deserializer);
    return (var_field0, var_field1);
  }
}

impl SseDecode for (String, crate::api::simple::ExposedUserDeviceSpecifiers) {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
    let mut var_field0 = <String>::sse_decode(deserializer);
    let mut var_field1 =
      <crate::api::simple::ExposedUserDeviceSpecifiers>::sse_decode(deserializer);
    return (var_field0, var_field1);
  }
}

impl SseDecode for u16 {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
    deserializer.cursor.read_u16::<NativeEndian>().unwrap()
  }
}

impl SseDecode for u32 {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
    deserializer.cursor.read_u32::<NativeEndian>().unwrap()
  }
}

impl SseDecode for u8 {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
    deserializer.cursor.read_u8().unwrap()
  }
}

impl SseDecode for () {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for crate::api::simple::UserConfigDeviceIdentifier {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
    let mut var_address = <String>::sse_decode(deserializer);
    let mut var_protocol = <String>::sse_decode(deserializer);
    let mut var_identifier = <Option<String>>::sse_decode(deserializer);
    return crate::api::simple::UserConfigDeviceIdentifier {
      address: var_address,
      protocol: var_protocol,
      identifier: var_identifier,
    };
  }
}

impl SseDecode for usize {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
    deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
  }
}

impl SseDecode for i32 {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
    deserializer.cursor.read_i32::<NativeEndian>().unwrap()
  }
}

fn pde_ffi_dispatcher_primary_impl(
  func_id: i32,
  port: flutter_rust_bridge::for_generated::MessagePort,
  ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
  rust_vec_len: i32,
  data_len: i32,
) {
  // Codec=Pde (Serialization + dispatch), see doc to use other codecs
  match func_id {
    11 => wire_crash_reporting_impl(port, ptr, rust_vec_len, data_len),
    7 => wire_generate_user_device_config_file_impl(port, ptr, rust_vec_len, data_len),
    8 => wire_get_protocol_names_impl(port, ptr, rust_vec_len, data_len),
    12 => wire_get_user_configs_impl(port, ptr, rust_vec_len, data_len),
    6 => wire_get_user_device_configs_impl(port, ptr, rust_vec_len, data_len),
    2 => wire_run_engine_impl(port, ptr, rust_vec_len, data_len),
    1 => wire_runtime_started_impl(port, ptr, rust_vec_len, data_len),
    3 => wire_send_impl(port, ptr, rust_vec_len, data_len),
    5 => wire_send_backend_server_message_impl(port, ptr, rust_vec_len, data_len),
    9 => wire_setup_logging_impl(port, ptr, rust_vec_len, data_len),
    10 => wire_shutdown_logging_impl(port, ptr, rust_vec_len, data_len),
    4 => wire_stop_engine_impl(port, ptr, rust_vec_len, data_len),
    _ => unreachable!(),
  }
}

fn pde_ffi_dispatcher_sync_impl(
  func_id: i32,
  ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
  rust_vec_len: i32,
  data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
  // Codec=Pde (Serialization + dispatch), see doc to use other codecs
  match func_id {
    _ => unreachable!(),
  }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ProtocolAttributesIdentifier> {
  fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
    flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0).into_dart()
  }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
  for FrbWrapper<ProtocolAttributesIdentifier>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ProtocolAttributesIdentifier>>
  for ProtocolAttributesIdentifier
{
  fn into_into_dart(self) -> FrbWrapper<ProtocolAttributesIdentifier> {
    self.into()
  }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ProtocolDeviceFeatures> {
  fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
    flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0).into_dart()
  }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
  for FrbWrapper<ProtocolDeviceFeatures>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ProtocolDeviceFeatures>>
  for ProtocolDeviceFeatures
{
  fn into_into_dart(self) -> FrbWrapper<ProtocolDeviceFeatures> {
    self.into()
  }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::simple::EngineOptionsExternal> {
  fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
    [
      self.0.device_config_json.into_into_dart().into_dart(),
      self.0.user_device_config_json.into_into_dart().into_dart(),
      self.0.server_name.into_into_dart().into_dart(),
      self
        .0
        .websocket_use_all_interfaces
        .into_into_dart()
        .into_dart(),
      self.0.websocket_port.into_into_dart().into_dart(),
      self.0.frontend_websocket_port.into_into_dart().into_dart(),
      self
        .0
        .frontend_in_process_channel
        .into_into_dart()
        .into_dart(),
      self.0.max_ping_time.into_into_dart().into_dart(),
      self.0.allow_raw_messages.into_into_dart().into_dart(),
      self.0.use_bluetooth_le.into_into_dart().into_dart(),
      self.0.use_serial_port.into_into_dart().into_dart(),
      self.0.use_hid.into_into_dart().into_dart(),
      self
        .0
        .use_lovense_dongle_serial
        .into_into_dart()
        .into_dart(),
      self.0.use_lovense_dongle_hid.into_into_dart().into_dart(),
      self.0.use_xinput.into_into_dart().into_dart(),
      self.0.use_lovense_connect.into_into_dart().into_dart(),
      self
        .0
        .use_device_websocket_server
        .into_into_dart()
        .into_dart(),
      self
        .0
        .device_websocket_server_port
        .into_into_dart()
        .into_dart(),
      self.0.crash_main_thread.into_into_dart().into_dart(),
      self.0.crash_task_thread.into_into_dart().into_dart(),
      self.0.websocket_client_address.into_into_dart().into_dart(),
      self.0.broadcast_server_mdns.into_into_dart().into_dart(),
      self.0.mdns_suffix.into_into_dart().into_dart(),
      self.0.repeater_mode.into_into_dart().into_dart(),
      self.0.repeater_local_port.into_into_dart().into_dart(),
      self.0.repeater_remote_address.into_into_dart().into_dart(),
    ]
    .into_dart()
  }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
  for FrbWrapper<crate::api::simple::EngineOptionsExternal>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::simple::EngineOptionsExternal>>
  for crate::api::simple::EngineOptionsExternal
{
  fn into_into_dart(self) -> FrbWrapper<crate::api::simple::EngineOptionsExternal> {
    self.into()
  }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::simple::ExposedUserConfig {
  fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
    [
      self.specifiers.into_into_dart().into_dart(),
      self.configurations.into_into_dart().into_dart(),
    ]
    .into_dart()
  }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
  for crate::api::simple::ExposedUserConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::simple::ExposedUserConfig>
  for crate::api::simple::ExposedUserConfig
{
  fn into_into_dart(self) -> crate::api::simple::ExposedUserConfig {
    self
  }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::simple::ExposedUserDeviceConfig {
  fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
    [
      self.identifier.into_into_dart().into_dart(),
      self.name.into_into_dart().into_dart(),
      self.display_name.into_into_dart().into_dart(),
      self.allow.into_into_dart().into_dart(),
      self.deny.into_into_dart().into_dart(),
      self.reserved_index.into_into_dart().into_dart(),
    ]
    .into_dart()
  }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
  for crate::api::simple::ExposedUserDeviceConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::simple::ExposedUserDeviceConfig>
  for crate::api::simple::ExposedUserDeviceConfig
{
  fn into_into_dart(self) -> crate::api::simple::ExposedUserDeviceConfig {
    self
  }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::simple::ExposedUserDeviceSpecifiers {
  fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
    [self.websocket.into_into_dart().into_dart()].into_dart()
  }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
  for crate::api::simple::ExposedUserDeviceSpecifiers
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::simple::ExposedUserDeviceSpecifiers>
  for crate::api::simple::ExposedUserDeviceSpecifiers
{
  fn into_into_dart(self) -> crate::api::simple::ExposedUserDeviceSpecifiers {
    self
  }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::simple::ExposedWebsocketSpecifier {
  fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
    [self.names.into_into_dart().into_dart()].into_dart()
  }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
  for crate::api::simple::ExposedWebsocketSpecifier
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::simple::ExposedWebsocketSpecifier>
  for crate::api::simple::ExposedWebsocketSpecifier
{
  fn into_into_dart(self) -> crate::api::simple::ExposedWebsocketSpecifier {
    self
  }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::simple::UserConfigDeviceIdentifier> {
  fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
    [
      self.0.address.into_into_dart().into_dart(),
      self.0.protocol.into_into_dart().into_dart(),
      self.0.identifier.into_into_dart().into_dart(),
    ]
    .into_dart()
  }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
  for FrbWrapper<crate::api::simple::UserConfigDeviceIdentifier>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::simple::UserConfigDeviceIdentifier>>
  for crate::api::simple::UserConfigDeviceIdentifier
{
  fn into_into_dart(self) -> FrbWrapper<crate::api::simple::UserConfigDeviceIdentifier> {
    self.into()
  }
}

impl SseEncode for flutter_rust_bridge::for_generated::anyhow::Error {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
    <String>::sse_encode(format!("{:?}", self), serializer);
  }
}

impl SseEncode for ProtocolAttributesIdentifier {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
    <RustOpaqueMoi<
      flutter_rust_bridge::for_generated::rust_async::RwLock<ProtocolAttributesIdentifier>,
    >>::sse_encode(
      flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
      serializer,
    );
  }
}

impl SseEncode for ProtocolDeviceFeatures {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
    <RustOpaqueMoi<flutter_rust_bridge::for_generated::rust_async::RwLock<ProtocolDeviceFeatures>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
  }
}

impl SseEncode for std::collections::HashMap<ProtocolAttributesIdentifier, ProtocolDeviceFeatures> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
    <Vec<(ProtocolAttributesIdentifier, ProtocolDeviceFeatures)>>::sse_encode(
      self.into_iter().collect(),
      serializer,
    );
  }
}

impl SseEncode
  for RustOpaqueMoi<
    flutter_rust_bridge::for_generated::rust_async::RwLock<ProtocolAttributesIdentifier>,
  >
{
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
    let (ptr, size) = self.sse_encode_raw();
    <usize>::sse_encode(ptr, serializer);
    <i32>::sse_encode(size, serializer);
  }
}

impl SseEncode
  for RustOpaqueMoi<flutter_rust_bridge::for_generated::rust_async::RwLock<ProtocolDeviceFeatures>>
{
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
    let (ptr, size) = self.sse_encode_raw();
    <usize>::sse_encode(ptr, serializer);
    <i32>::sse_encode(size, serializer);
  }
}

impl SseEncode for String {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
    <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
  }
}

impl SseEncode for bool {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
    serializer.cursor.write_u8(self as _).unwrap();
  }
}

impl SseEncode for crate::api::simple::EngineOptionsExternal {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
    <Option<String>>::sse_encode(self.device_config_json, serializer);
    <Option<String>>::sse_encode(self.user_device_config_json, serializer);
    <String>::sse_encode(self.server_name, serializer);
    <bool>::sse_encode(self.websocket_use_all_interfaces, serializer);
    <Option<u16>>::sse_encode(self.websocket_port, serializer);
    <Option<u16>>::sse_encode(self.frontend_websocket_port, serializer);
    <bool>::sse_encode(self.frontend_in_process_channel, serializer);
    <u32>::sse_encode(self.max_ping_time, serializer);
    <bool>::sse_encode(self.allow_raw_messages, serializer);
    <bool>::sse_encode(self.use_bluetooth_le, serializer);
    <bool>::sse_encode(self.use_serial_port, serializer);
    <bool>::sse_encode(self.use_hid, serializer);
    <bool>::sse_encode(self.use_lovense_dongle_serial, serializer);
    <bool>::sse_encode(self.use_lovense_dongle_hid, serializer);
    <bool>::sse_encode(self.use_xinput, serializer);
    <bool>::sse_encode(self.use_lovense_connect, serializer);
    <bool>::sse_encode(self.use_device_websocket_server, serializer);
    <Option<u16>>::sse_encode(self.device_websocket_server_port, serializer);
    <bool>::sse_encode(self.crash_main_thread, serializer);
    <bool>::sse_encode(self.crash_task_thread, serializer);
    <Option<String>>::sse_encode(self.websocket_client_address, serializer);
    <bool>::sse_encode(self.broadcast_server_mdns, serializer);
    <Option<String>>::sse_encode(self.mdns_suffix, serializer);
    <bool>::sse_encode(self.repeater_mode, serializer);
    <Option<u16>>::sse_encode(self.repeater_local_port, serializer);
    <Option<String>>::sse_encode(self.repeater_remote_address, serializer);
  }
}

impl SseEncode for crate::api::simple::ExposedUserConfig {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
    <Vec<(String, crate::api::simple::ExposedUserDeviceSpecifiers)>>::sse_encode(
      self.specifiers,
      serializer,
    );
    <Vec<crate::api::simple::ExposedUserDeviceConfig>>::sse_encode(self.configurations, serializer);
  }
}

impl SseEncode for crate::api::simple::ExposedUserDeviceConfig {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
    <crate::api::simple::UserConfigDeviceIdentifier>::sse_encode(self.identifier, serializer);
    <String>::sse_encode(self.name, serializer);
    <Option<String>>::sse_encode(self.display_name, serializer);
    <Option<bool>>::sse_encode(self.allow, serializer);
    <Option<bool>>::sse_encode(self.deny, serializer);
    <Option<u32>>::sse_encode(self.reserved_index, serializer);
  }
}

impl SseEncode for crate::api::simple::ExposedUserDeviceSpecifiers {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
    <Option<crate::api::simple::ExposedWebsocketSpecifier>>::sse_encode(self.websocket, serializer);
  }
}

impl SseEncode for crate::api::simple::ExposedWebsocketSpecifier {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
    <Vec<String>>::sse_encode(self.names, serializer);
  }
}

impl SseEncode for Vec<String> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
    <i32>::sse_encode(self.len() as _, serializer);
    for item in self {
      <String>::sse_encode(item, serializer);
    }
  }
}

impl SseEncode for Vec<crate::api::simple::ExposedUserDeviceConfig> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
    <i32>::sse_encode(self.len() as _, serializer);
    for item in self {
      <crate::api::simple::ExposedUserDeviceConfig>::sse_encode(item, serializer);
    }
  }
}

impl SseEncode for Vec<u8> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
    <i32>::sse_encode(self.len() as _, serializer);
    for item in self {
      <u8>::sse_encode(item, serializer);
    }
  }
}

impl SseEncode for Vec<(ProtocolAttributesIdentifier, ProtocolDeviceFeatures)> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
    <i32>::sse_encode(self.len() as _, serializer);
    for item in self {
      <(ProtocolAttributesIdentifier, ProtocolDeviceFeatures)>::sse_encode(item, serializer);
    }
  }
}

impl SseEncode for Vec<(String, crate::api::simple::ExposedUserDeviceSpecifiers)> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
    <i32>::sse_encode(self.len() as _, serializer);
    for item in self {
      <(String, crate::api::simple::ExposedUserDeviceSpecifiers)>::sse_encode(item, serializer);
    }
  }
}

impl SseEncode for Option<String> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
    <bool>::sse_encode(self.is_some(), serializer);
    if let Some(value) = self {
      <String>::sse_encode(value, serializer);
    }
  }
}

impl SseEncode for Option<bool> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
    <bool>::sse_encode(self.is_some(), serializer);
    if let Some(value) = self {
      <bool>::sse_encode(value, serializer);
    }
  }
}

impl SseEncode for Option<crate::api::simple::ExposedWebsocketSpecifier> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
    <bool>::sse_encode(self.is_some(), serializer);
    if let Some(value) = self {
      <crate::api::simple::ExposedWebsocketSpecifier>::sse_encode(value, serializer);
    }
  }
}

impl SseEncode for Option<u16> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
    <bool>::sse_encode(self.is_some(), serializer);
    if let Some(value) = self {
      <u16>::sse_encode(value, serializer);
    }
  }
}

impl SseEncode for Option<u32> {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
    <bool>::sse_encode(self.is_some(), serializer);
    if let Some(value) = self {
      <u32>::sse_encode(value, serializer);
    }
  }
}

impl SseEncode for (ProtocolAttributesIdentifier, ProtocolDeviceFeatures) {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
    <ProtocolAttributesIdentifier>::sse_encode(self.0, serializer);
    <ProtocolDeviceFeatures>::sse_encode(self.1, serializer);
  }
}

impl SseEncode for (String, crate::api::simple::ExposedUserDeviceSpecifiers) {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
    <String>::sse_encode(self.0, serializer);
    <crate::api::simple::ExposedUserDeviceSpecifiers>::sse_encode(self.1, serializer);
  }
}

impl SseEncode for u16 {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
    serializer.cursor.write_u16::<NativeEndian>(self).unwrap();
  }
}

impl SseEncode for u32 {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
    serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
  }
}

impl SseEncode for u8 {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
    serializer.cursor.write_u8(self).unwrap();
  }
}

impl SseEncode for () {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::api::simple::UserConfigDeviceIdentifier {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
    <String>::sse_encode(self.address, serializer);
    <String>::sse_encode(self.protocol, serializer);
    <Option<String>>::sse_encode(self.identifier, serializer);
  }
}

impl SseEncode for usize {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
    serializer
      .cursor
      .write_u64::<NativeEndian>(self as _)
      .unwrap();
  }
}

impl SseEncode for i32 {
  // Codec=Sse (Serialization based), see doc to use other codecs
  fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
    serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
  }
}

#[cfg(not(target_family = "wasm"))]
#[path = "frb_generated.io.rs"]
mod io;
#[cfg(not(target_family = "wasm"))]
pub use io::*;

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
#[path = "frb_generated.web.rs"]
mod web;
#[cfg(target_family = "wasm")]
pub use web::*;
